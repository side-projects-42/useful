{"version":3,"file":"socketio.js","sources":["../../presets/array-nonindex-keys.js","../../node_modules/typeson/dist/typeson-esm.js","../../types/undef.js","../../types/primitive-objects.js","../../presets/special-numbers.js","../../types/nan.js","../../types/infinity.js","../../types/negative-infinity.js","../../types/date.js","../../types/error.js","../../types/errors.js","../../node_modules/base64-arraybuffer-es6/dist/base64-arraybuffer-es.js","../../types/regexp.js","../../types/map.js","../../types/set.js","../../types/arraybuffer.js","../../types/typed-arrays.js","../../types/dataview.js","../../types/intl-types.js","../../types/bigint.js","../../types/bigint-object.js","../../presets/builtin.js","../../types/typed-arrays-socketio.js","../../presets/socketio.js"],"sourcesContent":["const arrayNonindexKeys = [\n    {\n        arrayNonindexKeys: {\n            testPlainObjects: true,\n            test (x, stateObj) {\n                if (Array.isArray(x)) {\n                    if (\n                        // By avoiding serializing arrays into objects which\n                        //  have only positive-integer keys, we reduce\n                        //  size and improve revival performance; arrays with\n                        //  non-index keys will be larger however\n                        Object.keys(x).some((k) => {\n                            //  No need to check for `isNaN` or\n                            //   `isNaN(parseInt())` as `NaN` will be treated\n                            //   as a string.\n                            //  No need to do check as `parseInt(Number())`\n                            //   since scientific notation will be\n                            //   pre-resolved if a number was given, and it\n                            //   will otherwise be a string\n                            return String(parseInt(k)) !== k;\n                        })\n                    ) {\n                        stateObj.iterateIn = 'object';\n                        stateObj.addLength = true;\n                    }\n                    return true;\n                }\n                return false;\n            },\n            replace (a, stateObj) {\n                if (Array.isArray(a)) {\n                    // Catch sparse undefined\n                    stateObj.iterateUnsetNumeric = true;\n                }\n                return a;\n            },\n            revive (o) {\n                if (Array.isArray(o)) {\n                    return o;\n                }\n                const arr = [];\n                // No map here as may be a sparse array (including\n                //   with `length` set)\n                // Todo: Reenable when Node `engines` >= 7\n                // Object.entries(o).forEach(([key, val]) => {\n                Object.keys(o).forEach((key) => {\n                    const val = o[key];\n                    arr[key] = val;\n                });\n                return arr;\n            }\n        }\n    },\n    {\n        sparseUndefined: {\n            test (x, stateObj) {\n                return typeof x === 'undefined' && stateObj.ownKeys === false;\n            },\n            replace (n) { return 0; },\n            revive (s) { return undefined; } // Will avoid adding anything\n        }\n    }\n];\n\nexport default arrayNonindexKeys;\n","function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\n/**\n * We keep this function minimized so if using two instances of this\n *   library, where one is minimized and one is not, it will still work\n *   with `hasConstructorOf`.\n * With ES6 classes, we may be able to simply use `class TypesonPromise\n *   extends Promise` and add a string tag for detection\n * @param {function} f\n */\nvar TypesonPromise = function TypesonPromise(f) {\n  _classCallCheck(this, TypesonPromise);\n\n  this.p = new Promise(f);\n}; // eslint-disable-line block-spacing, space-before-function-paren, space-before-blocks, space-infix-ops, semi\n// class TypesonPromise extends Promise {get[Symbol.toStringTag](){return 'TypesonPromise'};} // eslint-disable-line keyword-spacing, space-before-function-paren, space-before-blocks, block-spacing, semi\n// Note: core-js-bundle provides a `Symbol` polyfill\n\n\nif (typeof Symbol !== 'undefined') {\n  // Ensure `isUserObject` will return `false` for `TypesonPromise`\n  TypesonPromise.prototype[Symbol.toStringTag] = 'TypesonPromise';\n}\n/**\n *\n * @param {function} [onFulfilled]\n * @param {function} [onRejected]\n * @returns {TypesonPromise}\n */\n\n\nTypesonPromise.prototype.then = function (onFulfilled, onRejected) {\n  var _this = this;\n\n  return new TypesonPromise(function (typesonResolve, typesonReject) {\n    _this.p.then(function (res) {\n      typesonResolve(onFulfilled ? onFulfilled(res) : res);\n    }, function (r) {\n      _this.p['catch'](function (res) {\n        return onRejected ? onRejected(res) : Promise.reject(res);\n      }).then(typesonResolve, typesonReject);\n    });\n  });\n};\n/**\n *\n * @param {function} onRejected\n * @returns {TypesonPromise}\n */\n\n\nTypesonPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n/**\n *\n * @param {} v\n * @returns {TypesonPromise}\n */\n\n\nTypesonPromise.resolve = function (v) {\n  return new TypesonPromise(function (typesonResolve) {\n    typesonResolve(v);\n  });\n};\n/**\n *\n * @param {} v\n * @returns {TypesonPromise}\n */\n\n\nTypesonPromise.reject = function (v) {\n  return new TypesonPromise(function (typesonResolve, typesonReject) {\n    typesonReject(v);\n  });\n};\n\n['all', 'race'].map(function (meth) {\n  /**\n   *\n   * @param {Promise[]} promArr\n   * @returns {TypesonPromise}\n   */\n  TypesonPromise[meth] = function (promArr) {\n    return new TypesonPromise(function (typesonResolve, typesonReject) {\n      Promise[meth](promArr.map(function (prom) {\n        return prom.p;\n      })).then(typesonResolve, typesonReject);\n    });\n  };\n});\n\nvar _ref = {},\n    toString = _ref.toString,\n    hasOwn = {}.hasOwnProperty,\n    getProto = Object.getPrototypeOf,\n    fnToString = hasOwn.toString;\n/**\n *\n * @param {*} v\n * @param {boolean} catchCheck\n * @returns {boolean}\n */\n\nfunction isThenable(v, catchCheck) {\n  return isObject(v) && typeof v.then === 'function' && (!catchCheck || typeof v[\"catch\"] === 'function');\n}\n/**\n *\n * @param {*} val\n * @returns {string}\n */\n\n\nfunction toStringTag(val) {\n  return toString.call(val).slice(8, -1);\n}\n/**\n * This function is dependent on both constructors\n *   being identical so any minimization is expected of both.\n * @param {*} a\n * @param {function} b\n * @returns {boolean}\n */\n\n\nfunction hasConstructorOf(a, b) {\n  if (!a || _typeof(a) !== 'object') {\n    return false;\n  }\n\n  var proto = getProto(a);\n\n  if (!proto) {\n    return false;\n  }\n\n  var Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;\n\n  if (typeof Ctor !== 'function') {\n    return b === null;\n  }\n\n  return typeof Ctor === 'function' && b !== null && fnToString.call(Ctor) === fnToString.call(b);\n}\n/**\n *\n * @param {*} val\n * @returns {boolean}\n */\n\n\nfunction isPlainObject(val) {\n  // Mirrors jQuery's\n  if (!val || toStringTag(val) !== 'Object') {\n    return false;\n  }\n\n  var proto = getProto(val);\n\n  if (!proto) {\n    // `Object.create(null)`\n    return true;\n  }\n\n  return hasConstructorOf(val, Object);\n}\n/**\n *\n * @param {*} val\n * @returns {boolean}\n */\n\n\nfunction isUserObject(val) {\n  if (!val || toStringTag(val) !== 'Object') {\n    return false;\n  }\n\n  var proto = getProto(val);\n\n  if (!proto) {\n    // `Object.create(null)`\n    return true;\n  }\n\n  return hasConstructorOf(val, Object) || isUserObject(proto);\n}\n/**\n *\n * @param {*} v\n * @returns {boolean}\n */\n\n\nfunction isObject(v) {\n  return v && _typeof(v) === 'object';\n}\n/**\n *\n * @param {string} keyPathComponent\n * @returns {string}\n */\n\n\nfunction escapeKeyPathComponent(keyPathComponent) {\n  return keyPathComponent.replace(/~/g, '~0').replace(/\\./g, '~1');\n}\n/**\n *\n * @param {string} keyPathComponent\n * @returns {string}\n */\n\n\nfunction unescapeKeyPathComponent(keyPathComponent) {\n  return keyPathComponent.replace(/~1/g, '.').replace(/~0/g, '~');\n}\n/**\n * @param {object|array} obj\n * @param {string} keyPath\n * @returns {*}\n */\n\n\nfunction getByKeyPath(obj, keyPath) {\n  if (keyPath === '') {\n    return obj;\n  }\n\n  var period = keyPath.indexOf('.');\n\n  if (period > -1) {\n    var innerObj = obj[unescapeKeyPathComponent(keyPath.substr(0, period))];\n    return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n  }\n\n  return obj[unescapeKeyPathComponent(keyPath)];\n}\n\nfunction setAtKeyPath(obj, keyPath, value) {\n  if (keyPath === '') {\n    return value;\n  }\n\n  var period = keyPath.indexOf('.');\n\n  if (period > -1) {\n    var innerObj = obj[unescapeKeyPathComponent(keyPath.substr(0, period))];\n    return setAtKeyPath(innerObj, keyPath.substr(period + 1), value);\n  }\n\n  obj[unescapeKeyPathComponent(keyPath)] = value;\n  return obj;\n}\n/**\n *\n * @param {external:JSON} value\n * @returns {\"null\"|\"array\"|\"undefined\"|\"boolean\"|\"number\"|\"string\"|\"object\"|\"symbol\"}\n */\n\n\nfunction getJSONType(value) {\n  return value === null ? 'null' : Array.isArray(value) ? 'array' : _typeof(value);\n}\n\nvar keys = Object.keys,\n    isArray = Array.isArray,\n    hasOwn$1 = {}.hasOwnProperty,\n    internalStateObjPropsToIgnore = ['type', 'replaced', 'iterateIn', 'iterateUnsetNumeric'];\n\nfunction nestedPathsFirst(a, b) {\n  var as = a.keypath.match(/\\./g);\n  var bs = a.keypath.match(/\\./g);\n\n  if (as) {\n    as = as.length;\n  }\n\n  if (bs) {\n    bs = bs.length;\n  }\n\n  return as > bs ? -1 : as < bs ? 1 : a.keypath < b.keypath ? -1 : a.keypath > b.keypath;\n}\n/**\n * An instance of this class can be used to call `stringify()` and `parse()`.\n * Typeson resolves cyclic references by default. Can also be extended to\n * support custom types using the register() method.\n *\n * @constructor\n * @param {{cyclic: boolean}} [options] - if cyclic (default true),\n *   cyclic references will be handled gracefully.\n */\n\n\nvar Typeson =\n/*#__PURE__*/\nfunction () {\n  function Typeson(options) {\n    _classCallCheck(this, Typeson);\n\n    this.options = options; // Replacers signature: replace (value). Returns falsy if not\n    //   replacing. Otherwise ['Date', value.getTime()]\n\n    this.plainObjectReplacers = [];\n    this.nonplainObjectReplacers = []; // Revivers: [{type => reviver}, {plain: boolean}].\n    //   Sample: [{'Date': value => new Date(value)}, {plain: false}]\n\n    this.revivers = {};\n    /** Types registered via register() */\n\n    this.types = {};\n  }\n  /**\n   * Serialize given object to Typeson.\n   * Initial arguments work identical to those of `JSON.stringify`.\n   * The `replacer` argument has nothing to do with our replacers.\n   * @param {*} obj\n   * @param {function|string[]} replacer\n   * @param {number|string} space\n   * @param {object} opts\n   * @returns {string|Promise} Promise resolves to a string\n   */\n\n\n  _createClass(Typeson, [{\n    key: \"stringify\",\n    value: function stringify(obj, replacer, space, opts) {\n      opts = _objectSpread({}, this.options, opts, {\n        stringification: true\n      });\n      var encapsulated = this.encapsulate(obj, null, opts);\n\n      if (isArray(encapsulated)) {\n        return JSON.stringify(encapsulated[0], replacer, space);\n      }\n\n      return encapsulated.then(function (res) {\n        return JSON.stringify(res, replacer, space);\n      });\n    }\n    /**\n     * Also sync but throws on non-sync result\n     * @param {*} obj\n     * @param {function|string[]} replacer\n     * @param {number|string} space\n     * @param {object} opts\n     * @returns {string}\n     */\n\n  }, {\n    key: \"stringifySync\",\n    value: function stringifySync(obj, replacer, space, opts) {\n      return this.stringify(obj, replacer, space, _objectSpread({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: true\n      }));\n    }\n    /**\n     *\n     * @param {*} obj\n     * @param {function|string[]} replacer\n     * @param {number|string} space\n     * @param {object} opts\n     * @returns {Promise} Resolves to string\n     */\n\n  }, {\n    key: \"stringifyAsync\",\n    value: function stringifyAsync(obj, replacer, space, opts) {\n      return this.stringify(obj, replacer, space, _objectSpread({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: false\n      }));\n    }\n    /**\n     * Parse Typeson back into an obejct.\n     * Initial arguments works identical to those of `JSON.parse()`.\n     * @param {string} text\n     * @param {function} reviver This JSON reviver has nothing to do with\n     *   our revivers.\n     * @param {object} opts\n     * @returns {external:JSON}\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(text, reviver, opts) {\n      opts = _objectSpread({}, this.options, opts, {\n        parse: true\n      });\n      return this.revive(JSON.parse(text, reviver), opts);\n    }\n    /**\n    * Also sync but throws on non-sync result\n    * @param {string} text\n    * @param {function} reviver This JSON reviver has nothing to do with\n    *   our revivers.\n    * @param {object} opts\n    * @returns {external:JSON}\n    */\n\n  }, {\n    key: \"parseSync\",\n    value: function parseSync(text, reviver, opts) {\n      return this.parse(text, reviver, _objectSpread({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: true\n      }));\n    }\n    /**\n    * @param {string} text\n    * @param {function} reviver This JSON reviver has nothing to do with\n    *   our revivers.\n    * @param {object} opts\n    * @returns {Promise} Resolves to `external:JSON`\n    */\n\n  }, {\n    key: \"parseAsync\",\n    value: function parseAsync(text, reviver, opts) {\n      return this.parse(text, reviver, _objectSpread({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: false\n      }));\n    }\n    /**\n     *\n     * @param {*} obj\n     * @param {object} stateObj\n     * @param {object} [opts={}]\n     * @returns {string[]|false}\n     */\n\n  }, {\n    key: \"specialTypeNames\",\n    value: function specialTypeNames(obj, stateObj) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.returnTypeNames = true;\n      return this.encapsulate(obj, stateObj, opts);\n    }\n    /**\n     *\n     * @param {*} obj\n     * @param {object} stateObj\n     * @param {object} [opts={}]\n     * @returns {Promise|Array|object|string|false}\n     */\n\n  }, {\n    key: \"rootTypeName\",\n    value: function rootTypeName(obj, stateObj) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.iterateNone = true;\n      return this.encapsulate(obj, stateObj, opts);\n    }\n    /**\n     * Encapsulate a complex object into a plain Object by replacing\n     * registered types with plain objects representing the types data.\n     *\n     * This method is used internally by T`ypeson.stringify()`.\n     * @param {Object} obj - Object to encapsulate.\n     * @param {object} stateObj\n     * @param {object} opts\n     * @returns {Promise|Array|object|string|false}\n     */\n\n  }, {\n    key: \"encapsulate\",\n    value: function encapsulate(obj, stateObj, opts) {\n      opts = _objectSpread({\n        sync: true\n      }, this.options, opts);\n      var _opts = opts,\n          sync = _opts.sync;\n      var that = this,\n          types = {},\n          refObjs = [],\n          // For checking cyclic references\n      refKeys = [],\n          // For checking cyclic references\n      promisesDataRoot = []; // Clone the object deeply while at the same time replacing any\n      //   special types or cyclic reference:\n\n      var cyclic = 'cyclic' in opts ? opts.cyclic : true;\n      var _opts2 = opts,\n          encapsulateObserver = _opts2.encapsulateObserver;\n\n      var ret = _encapsulate('', obj, cyclic, stateObj || {}, promisesDataRoot);\n      /**\n       *\n       * @param {*} ret\n       * @returns {Array|object|string|false}\n       */\n\n\n      function finish(ret) {\n        // Add `$types` to result only if we ever bumped into a\n        //  special type (or special case where object has own `$types`)\n        var typeNames = Object.values(types);\n\n        if (opts.iterateNone) {\n          if (typeNames.length) {\n            return typeNames[0];\n          }\n\n          return Typeson.getJSONType(ret);\n        }\n\n        if (typeNames.length) {\n          if (opts.returnTypeNames) {\n            return _toConsumableArray(new Set(typeNames));\n          } // Special if array (or a primitive) was serialized\n          //   because JSON would ignore custom `$types` prop on it\n\n\n          if (!ret || !isPlainObject(ret) || // Also need to handle if this is an object with its\n          //   own `$types` property (to avoid ambiguity)\n          hasOwn$1.call(ret, '$types')) {\n            ret = {\n              $: ret,\n              $types: {\n                $: types\n              }\n            };\n          } else {\n            ret.$types = types;\n          } // No special types\n\n        } else if (isObject(ret) && hasOwn$1.call(ret, '$types')) {\n          ret = {\n            $: ret,\n            $types: true\n          };\n        }\n\n        if (opts.returnTypeNames) {\n          return false;\n        }\n\n        return ret;\n      }\n      /**\n       *\n       * @param {*} ret\n       * @param {array} promisesData\n       * @returns {Promise} Resolves to ...\n       */\n\n\n      function checkPromises(_x, _x2) {\n        return _checkPromises.apply(this, arguments);\n      }\n      /**\n       *\n       * @param {object} stateObj\n       * @param {object} ownKeysObj\n       * @param {function} cb\n       * @returns {undefined}\n       */\n\n\n      function _checkPromises() {\n        _checkPromises = _asyncToGenerator(\n        /*#__PURE__*/\n        regeneratorRuntime.mark(function _callee2(ret, promisesData) {\n          var promResults;\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return Promise.all(promisesData.map(function (pd) {\n                    return pd[1].p;\n                  }));\n\n                case 2:\n                  promResults = _context2.sent;\n                  _context2.next = 5;\n                  return Promise.all(promResults.map(\n                  /*#__PURE__*/\n                  function () {\n                    var _ref = _asyncToGenerator(\n                    /*#__PURE__*/\n                    regeneratorRuntime.mark(function _callee(promResult) {\n                      var newPromisesData, _promisesData$splice, _promisesData$splice2, prData, _prData, keyPath, cyclic, stateObj, parentObj, key, detectedType, encaps, isTypesonPromise, encaps2;\n\n                      return regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              newPromisesData = [];\n                              _promisesData$splice = promisesData.splice(0, 1), _promisesData$splice2 = _slicedToArray(_promisesData$splice, 1), prData = _promisesData$splice2[0];\n                              _prData = _slicedToArray(prData, 7), keyPath = _prData[0], cyclic = _prData[2], stateObj = _prData[3], parentObj = _prData[4], key = _prData[5], detectedType = _prData[6];\n                              encaps = _encapsulate(keyPath, promResult, cyclic, stateObj, newPromisesData, true, detectedType);\n                              isTypesonPromise = hasConstructorOf(encaps, TypesonPromise); // Handle case where an embedded custom type itself\n                              //   returns a `Typeson.Promise`\n\n                              if (!(keyPath && isTypesonPromise)) {\n                                _context.next = 11;\n                                break;\n                              }\n\n                              _context.next = 8;\n                              return encaps.p;\n\n                            case 8:\n                              encaps2 = _context.sent;\n                              parentObj[key] = encaps2;\n                              return _context.abrupt(\"return\", checkPromises(ret, newPromisesData));\n\n                            case 11:\n                              if (keyPath) {\n                                parentObj[key] = encaps;\n                              } else if (isTypesonPromise) {\n                                ret = encaps.p;\n                              } else {\n                                // If this is itself a `Typeson.Promise` (because the\n                                //   original value supplied was a `Promise` or\n                                //   because the supplied custom type value resolved\n                                //   to one), returning it below will be fine since\n                                //   a `Promise` is expected anyways given current\n                                //   config (and if not a `Promise`, it will be ready\n                                //   as the resolve value)\n                                ret = encaps;\n                              }\n\n                              return _context.abrupt(\"return\", checkPromises(ret, newPromisesData));\n\n                            case 13:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee);\n                    }));\n\n                    return function (_x3) {\n                      return _ref.apply(this, arguments);\n                    };\n                  }()));\n\n                case 5:\n                  return _context2.abrupt(\"return\", ret);\n\n                case 6:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n        return _checkPromises.apply(this, arguments);\n      }\n\n      function _adaptBuiltinStateObjectProperties(stateObj, ownKeysObj, cb) {\n        Object.assign(stateObj, ownKeysObj);\n        var vals = internalStateObjPropsToIgnore.map(function (prop) {\n          var tmp = stateObj[prop];\n          delete stateObj[prop];\n          return tmp;\n        });\n        cb();\n        internalStateObjPropsToIgnore.forEach(function (prop, i) {\n          stateObj[prop] = vals[i];\n        });\n      }\n      /**\n       *\n       * @param {string} keypath\n       * @param {*} value\n       * @param {boolean} cyclic\n       * @param {object} stateObj\n       * @param {boolean} promisesData\n       * @param {boolean} resolvingTypesonPromise\n       * @param {string} detectedType\n       * @returns {*}\n       */\n\n\n      function _encapsulate(keypath, value, cyclic, stateObj, promisesData, resolvingTypesonPromise, detectedType) {\n        var ret;\n        var observerData = {};\n\n        var $typeof = _typeof(value);\n\n        var runObserver = encapsulateObserver ? function (obj) {\n          var type = detectedType || stateObj.type || Typeson.getJSONType(value);\n          encapsulateObserver(Object.assign(obj || observerData, {\n            keypath: keypath,\n            value: value,\n            cyclic: cyclic,\n            stateObj: stateObj,\n            promisesData: promisesData,\n            resolvingTypesonPromise: resolvingTypesonPromise,\n            awaitingTypesonPromise: hasConstructorOf(value, TypesonPromise)\n          }, type !== undefined ? {\n            type: type\n          } : {}));\n        } : null;\n\n        if (['string', 'boolean', 'number', 'undefined'].includes($typeof)) {\n          if (value === undefined || $typeof === 'number' && (isNaN(value) || value === -Infinity || value === Infinity)) {\n            ret = replace(keypath, value, stateObj, promisesData, false, resolvingTypesonPromise, runObserver);\n\n            if (ret !== value) {\n              observerData = {\n                replaced: ret\n              };\n            }\n          } else {\n            ret = value;\n          }\n\n          if (runObserver) {\n            runObserver();\n          }\n\n          return ret;\n        }\n\n        if (value === null) {\n          if (runObserver) {\n            runObserver();\n          }\n\n          return value;\n        }\n\n        if (cyclic && !stateObj.iterateIn && !stateObj.iterateUnsetNumeric) {\n          // Options set to detect cyclic references and be able\n          //   to rewrite them.\n          var refIndex = refObjs.indexOf(value);\n\n          if (refIndex < 0) {\n            if (cyclic === true) {\n              refObjs.push(value);\n              refKeys.push(keypath);\n            }\n          } else {\n            types[keypath] = '#';\n\n            if (runObserver) {\n              runObserver({\n                cyclicKeypath: refKeys[refIndex]\n              });\n            }\n\n            return '#' + refKeys[refIndex];\n          }\n        }\n\n        var isPlainObj = isPlainObject(value);\n        var isArr = isArray(value);\n        var replaced = // Running replace will cause infinite loop as will test\n        //   positive again\n        (isPlainObj || isArr) && (!that.plainObjectReplacers.length || stateObj.replaced) || stateObj.iterateIn ? // Optimization: if plain object and no plain-object\n        //   replacers, don't try finding a replacer\n        value : replace(keypath, value, stateObj, promisesData, isPlainObj || isArr, null, runObserver);\n        var clone;\n\n        if (replaced !== value) {\n          ret = replaced;\n          observerData = {\n            replaced: replaced\n          };\n        } else {\n          if (isArr && stateObj.iterateIn !== 'object' || stateObj.iterateIn === 'array') {\n            clone = new Array(value.length);\n            observerData = {\n              clone: clone\n            };\n          } else if (isPlainObj || stateObj.iterateIn === 'object') {\n            clone = {};\n\n            if (stateObj.addLength) {\n              clone.length = value.length;\n            }\n\n            observerData = {\n              clone: clone\n            };\n          } else if (keypath === '' && hasConstructorOf(value, TypesonPromise)) {\n            promisesData.push([keypath, value, cyclic, stateObj, undefined, undefined, stateObj.type]);\n            ret = value;\n          } else {\n            ret = value; // Only clone vanilla objects and arrays\n          }\n        }\n\n        if (runObserver) {\n          runObserver();\n        }\n\n        if (opts.iterateNone) {\n          return clone || ret;\n        }\n\n        if (!clone) {\n          return ret;\n        } // Iterate object or array\n\n\n        if (stateObj.iterateIn) {\n          var _loop = function _loop(key) {\n            var ownKeysObj = {\n              ownKeys: hasOwn$1.call(value, key)\n            };\n\n            _adaptBuiltinStateObjectProperties(stateObj, ownKeysObj, function () {\n              var kp = keypath + (keypath ? '.' : '') + escapeKeyPathComponent(key);\n\n              var val = _encapsulate(kp, value[key], !!cyclic, stateObj, promisesData, resolvingTypesonPromise);\n\n              if (hasConstructorOf(val, TypesonPromise)) {\n                promisesData.push([kp, val, !!cyclic, stateObj, clone, key, stateObj.type]);\n              } else if (val !== undefined) {\n                clone[key] = val;\n              }\n            });\n          };\n\n          for (var key in value) {\n            _loop(key);\n          }\n\n          if (runObserver) {\n            runObserver({\n              endIterateIn: true,\n              end: true\n            });\n          }\n        } else {\n          // Note: Non-indexes on arrays won't survive stringify so\n          //  somewhat wasteful for arrays, but so too is iterating\n          //  all numeric indexes on sparse arrays when not wanted\n          //  or filtering own keys for positive integers\n          keys(value).forEach(function (key) {\n            var kp = keypath + (keypath ? '.' : '') + escapeKeyPathComponent(key);\n            var ownKeysObj = {\n              ownKeys: true\n            };\n\n            _adaptBuiltinStateObjectProperties(stateObj, ownKeysObj, function () {\n              var val = _encapsulate(kp, value[key], !!cyclic, stateObj, promisesData, resolvingTypesonPromise);\n\n              if (hasConstructorOf(val, TypesonPromise)) {\n                promisesData.push([kp, val, !!cyclic, stateObj, clone, key, stateObj.type]);\n              } else if (val !== undefined) {\n                clone[key] = val;\n              }\n            });\n          });\n\n          if (runObserver) {\n            runObserver({\n              endIterateOwn: true,\n              end: true\n            });\n          }\n        } // Iterate array for non-own numeric properties (we can't\n        //   replace the prior loop though as it iterates non-integer\n        //   keys)\n\n\n        if (stateObj.iterateUnsetNumeric) {\n          var vl = value.length;\n\n          var _loop2 = function _loop2(i) {\n            if (!(i in value)) {\n              // No need to escape numeric\n              var kp = keypath + (keypath ? '.' : '') + i;\n              var ownKeysObj = {\n                ownKeys: false\n              };\n\n              _adaptBuiltinStateObjectProperties(stateObj, ownKeysObj, function () {\n                var val = _encapsulate(kp, undefined, !!cyclic, stateObj, promisesData, resolvingTypesonPromise);\n\n                if (hasConstructorOf(val, TypesonPromise)) {\n                  promisesData.push([kp, val, !!cyclic, stateObj, clone, i, stateObj.type]);\n                } else if (val !== undefined) {\n                  clone[i] = val;\n                }\n              });\n            }\n          };\n\n          for (var i = 0; i < vl; i++) {\n            _loop2(i);\n          }\n\n          if (runObserver) {\n            runObserver({\n              endIterateUnsetNumeric: true,\n              end: true\n            });\n          }\n        }\n\n        return clone;\n      }\n      /**\n       *\n       * @param {string} keypath\n       * @param {*} value\n       * @param {object} stateObj\n       * @param {array} promisesData\n       * @param {boolean} plainObject\n       * @param {boolean} resolvingTypesonPromise\n       * @param {function} [runObserver]\n       * @returns {*}\n       */\n\n\n      function replace(keypath, value, stateObj, promisesData, plainObject, resolvingTypesonPromise, runObserver) {\n        // Encapsulate registered types\n        var replacers = plainObject ? that.plainObjectReplacers : that.nonplainObjectReplacers;\n        var i = replacers.length;\n\n        while (i--) {\n          var replacer = replacers[i];\n\n          if (replacer.test(value, stateObj)) {\n            var type = replacer.type;\n\n            if (that.revivers[type]) {\n              // Record the type only if a corresponding reviver\n              //   exists. This is to support specs where only\n              //   replacement is done.\n              // For example, ensuring deep cloning of the object,\n              //   or replacing a type to its equivalent without\n              //   the need to revive it.\n              var existing = types[keypath]; // type can comprise an array of types (see test\n              //   `shouldSupportIntermediateTypes`)\n\n              types[keypath] = existing ? [type].concat(existing) : type;\n            } // Now, also traverse the result in case it contains its\n            //   own types to replace\n\n\n            Object.assign(stateObj, {\n              type: type,\n              replaced: true\n            });\n\n            if ((sync || !replacer.replaceAsync) && !replacer.replace) {\n              if (runObserver) {\n                runObserver({\n                  typeDetected: true\n                });\n              }\n\n              return _encapsulate(keypath, value, cyclic && 'readonly', stateObj, promisesData, resolvingTypesonPromise, type);\n            }\n\n            if (runObserver) {\n              runObserver({\n                replacing: true\n              });\n            }\n\n            var replaceMethod = sync || !replacer.replaceAsync ? 'replace' : 'replaceAsync';\n            return _encapsulate(keypath, replacer[replaceMethod](value, stateObj), cyclic && 'readonly', stateObj, promisesData, resolvingTypesonPromise, type);\n          }\n        }\n\n        return value;\n      }\n\n      return promisesDataRoot.length ? sync && opts.throwOnBadSyncType ? function () {\n        throw new TypeError('Sync method requested but async result obtained');\n      }() : Promise.resolve(checkPromises(ret, promisesDataRoot)).then(finish) : !sync && opts.throwOnBadSyncType ? function () {\n        throw new TypeError('Async method requested but sync result obtained');\n      }() // If this is a synchronous request for stringification, yet\n      //   a promise is the result, we don't want to resolve leading\n      //   to an async result, so we return an array to avoid\n      //   ambiguity\n      : opts.stringification && sync ? [finish(ret)] : sync ? finish(ret) : Promise.resolve(finish(ret));\n    }\n    /**\n     * Also sync but throws on non-sync result\n     * @param {*} obj\n     * @param {object} stateObj\n     * @param {object} opts\n     * @returns {*}\n     */\n\n  }, {\n    key: \"encapsulateSync\",\n    value: function encapsulateSync(obj, stateObj, opts) {\n      return this.encapsulate(obj, stateObj, _objectSpread({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: true\n      }));\n    }\n    /**\n     * @param {*} obj\n     * @param {object} stateObj\n     * @param {object} opts\n     * @returns {*}\n     */\n\n  }, {\n    key: \"encapsulateAsync\",\n    value: function encapsulateAsync(obj, stateObj, opts) {\n      return this.encapsulate(obj, stateObj, _objectSpread({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: false\n      }));\n    }\n    /**\n     * Revive an encapsulated object.\n     * This method is used internally by `Typeson.parse()`.\n     * @param {object} obj - Object to revive. If it has `$types` member, the\n     *   properties that are listed there will be replaced with its true type\n     *   instead of just plain objects.\n     * @param {object} opts\n     * @throws TypeError If mismatch between sync/async type and result\n     * @returns {Promise|*} If async, returns a Promise that resolves to `*`\n     */\n\n  }, {\n    key: \"revive\",\n    value: function revive(obj, opts) {\n      var types = obj && obj.$types; // No type info added. Revival not needed.\n\n      if (!types) {\n        return obj;\n      } // Object happened to have own `$types` property but with\n      //   no actual types, so we unescape and return that object\n\n\n      if (types === true) {\n        return obj.$;\n      }\n\n      opts = _objectSpread({\n        sync: true\n      }, this.options, opts);\n      var _opts3 = opts,\n          sync = _opts3.sync;\n      var keyPathResolutions = [];\n      var stateObj = {};\n      var ignore$Types = true; // Special when root object is not a trivial Object, it will\n      //   be encapsulated in `$`. It will also be encapsulated in\n      //   `$` if it has its own `$` property to avoid ambiguity\n\n      if (types.$ && isPlainObject(types.$)) {\n        obj = obj.$;\n        types = types.$;\n        ignore$Types = false;\n      }\n\n      var that = this;\n\n      function revivePlainObjects() {\n        // const references = [];\n        // const reviveTypes = [];\n        var plainObjectTypes = [];\n        Object.entries(types).forEach(function (_ref2) {\n          var _ref3 = _slicedToArray(_ref2, 2),\n              keypath = _ref3[0],\n              type = _ref3[1];\n\n          if (type === '#') {\n            /*\n            references.push({\n                keypath,\n                reference: getByKeyPath(obj, keypath)\n            });\n            */\n            return;\n          }\n\n          [].concat(type).forEach(function (type) {\n            var _that$revivers$type = _slicedToArray(that.revivers[type], 2),\n                plain = _that$revivers$type[1].plain;\n\n            if (!plain) {\n              // reviveTypes.push({keypath, type});\n              return;\n            }\n\n            plainObjectTypes.push({\n              keypath: keypath,\n              type: type\n            });\n            delete types[keypath]; // Avoid repeating\n          });\n        });\n\n        if (!plainObjectTypes.length) {\n          return;\n        } // Handle plain object revivers first so reference\n        //   setting can use revived type (e.g., array instead\n        //   of object); assumes revived has same structure\n        //   or will otherwise break subsequent references\n\n\n        return plainObjectTypes.sort(nestedPathsFirst).reduce(function reducer(possibleTypesonPromise, _ref4) {\n          var keypath = _ref4.keypath,\n              type = _ref4.type;\n\n          if (hasConstructorOf(possibleTypesonPromise, TypesonPromise)) {\n            // TypesonPromise here too\n            return possibleTypesonPromise.then(function (v) {\n              return reducer(v, type);\n            });\n          }\n\n          var val = getByKeyPath(obj, keypath);\n\n          if (hasConstructorOf(val, TypesonPromise)) {\n            return val.then(function (v) {\n              // TypesonPromise here too\n              return reducer(v, type);\n            });\n          }\n\n          var _that$revivers$type2 = _slicedToArray(that.revivers[type], 1),\n              reviver = _that$revivers$type2[0];\n\n          if (!reviver) {\n            throw new Error('Unregistered type: ' + type);\n          }\n\n          val = reviver[sync && reviver.revive ? 'revive' : !sync && reviver.reviveAsync ? 'reviveAsync' : 'revive'](val, stateObj);\n\n          if (val === undefined) {\n            return undefined;\n          }\n\n          if (hasConstructorOf(val, Undefined)) {\n            val = undefined;\n          }\n\n          var newVal = setAtKeyPath(obj, keypath, val);\n\n          if (newVal === val) {\n            obj = val;\n          }\n\n          return undefined;\n        }, undefined // This argument must be explicit\n        ); // references.forEach(({keypath, reference}) => {});\n        // reviveTypes.sort(nestedPathsFirst).forEach(() => {});\n      }\n      /**\n       *\n       * @param {string} keypath\n       * @param {*} value\n       * @param {?(Array|object)} target\n       * @param {Array|object} [clone]\n       * @param {string} [key]\n       * @returns {*}\n       */\n\n\n      function _revive(keypath, value, target, clone, key) {\n        if (ignore$Types && keypath === '$types') {\n          return undefined;\n        }\n\n        var type = types[keypath];\n\n        if (isArray(value) || isPlainObject(value)) {\n          var _clone = isArray(value) ? new Array(value.length) : {}; // Iterate object or array\n\n\n          keys(value).forEach(function (k) {\n            var val = _revive(keypath + (keypath ? '.' : '') + escapeKeyPathComponent(k), value[k], target || _clone, _clone, k);\n\n            if (hasConstructorOf(val, Undefined)) {\n              _clone[k] = undefined;\n            } else if (val !== undefined) {\n              _clone[k] = val;\n            }\n          });\n          value = _clone; // Try to resolve cyclic reference as soon as available\n\n          while (keyPathResolutions.length) {\n            var _keyPathResolutions$ = _slicedToArray(keyPathResolutions[0], 4),\n                _target = _keyPathResolutions$[0],\n                keyPath = _keyPathResolutions$[1],\n                _clone2 = _keyPathResolutions$[2],\n                k = _keyPathResolutions$[3];\n\n            var val = getByKeyPath(_target, keyPath);\n\n            if (hasConstructorOf(val, Undefined)) {\n              _clone2[k] = undefined;\n            } else if (val !== undefined) {\n              _clone2[k] = val;\n            } else {\n              break;\n            }\n\n            keyPathResolutions.splice(0, 1);\n          }\n        }\n\n        if (!type) {\n          return value;\n        }\n\n        if (type === '#') {\n          var _ret = getByKeyPath(target, value.slice(1));\n\n          if (_ret === undefined) {\n            // Cyclic reference not yet available\n            keyPathResolutions.push([target, value.slice(1), clone, key]);\n          }\n\n          return _ret;\n        }\n\n        return [].concat(type).reduce(function reducer(val, type) {\n          if (hasConstructorOf(val, TypesonPromise)) {\n            return val.then(function (v) {\n              // TypesonPromise here too\n              return reducer(v, type);\n            });\n          }\n\n          var _that$revivers$type3 = _slicedToArray(that.revivers[type], 1),\n              reviver = _that$revivers$type3[0];\n\n          if (!reviver) {\n            throw new Error('Unregistered type: ' + type);\n          }\n\n          return reviver[sync && reviver.revive ? 'revive' : !sync && reviver.reviveAsync ? 'reviveAsync' : 'revive'](val, stateObj);\n        }, value);\n      }\n\n      function checkUndefined(retrn) {\n        return hasConstructorOf(retrn, Undefined) ? undefined : retrn;\n      }\n\n      var possibleTypesonPromise = revivePlainObjects();\n      var ret;\n\n      if (hasConstructorOf(possibleTypesonPromise, TypesonPromise)) {\n        ret = possibleTypesonPromise.then(function () {\n          return _revive('', obj, null);\n        });\n      } else {\n        ret = _revive('', obj, null);\n      }\n\n      return isThenable(ret) ? sync && opts.throwOnBadSyncType ? function () {\n        throw new TypeError('Sync method requested but async result obtained');\n      }() : hasConstructorOf(ret, TypesonPromise) ? ret.p.then(checkUndefined) : ret : !sync && opts.throwOnBadSyncType ? function () {\n        throw new TypeError('Async method requested but sync result obtained');\n      }() : sync ? checkUndefined(ret) : Promise.resolve(checkUndefined(ret));\n    }\n    /**\n     * Also sync but throws on non-sync result\n     * @param {*} obj\n     * @param {object} opts\n     * @returns {*}\n     */\n\n  }, {\n    key: \"reviveSync\",\n    value: function reviveSync(obj, opts) {\n      return this.revive(obj, _objectSpread({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: true\n      }));\n    }\n    /**\n    * @param {*} obj\n    * @param {object} opts\n    * @returns {Promise} Resolves to `*`\n    */\n\n  }, {\n    key: \"reviveAsync\",\n    value: function reviveAsync(obj, opts) {\n      return this.revive(obj, _objectSpread({\n        throwOnBadSyncType: true\n      }, opts, {\n        sync: false\n      }));\n    }\n    /**\n     * Register types.\n     * For examples on how to use this method, see\n     *   {@link https://github.com/dfahlander/typeson-registry/tree/master/types}\n     * @param {Array.<Object.<string,Function[]>>} typeSpecSets - Types and\n     *   their functions [test, encapsulate, revive];\n     * @param {object} opts\n     * @returns {Typeson}\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(typeSpecSets, opts) {\n      opts = opts || {};\n      [].concat(typeSpecSets).forEach(function R(typeSpec) {\n        // Allow arrays of arrays of arrays...\n        if (isArray(typeSpec)) {\n          return typeSpec.map(R, this);\n        }\n\n        typeSpec && keys(typeSpec).forEach(function (typeId) {\n          if (typeId === '#') {\n            throw new TypeError('# cannot be used as a type name as it is reserved ' + 'for cyclic objects');\n          } else if (Typeson.JSON_TYPES.includes(typeId)) {\n            throw new TypeError('Plain JSON object types are reserved as type names');\n          }\n\n          var spec = typeSpec[typeId];\n          var replacers = spec.testPlainObjects ? this.plainObjectReplacers : this.nonplainObjectReplacers;\n          var existingReplacer = replacers.filter(function (r) {\n            return r.type === typeId;\n          });\n\n          if (existingReplacer.length) {\n            // Remove existing spec and replace with this one.\n            replacers.splice(replacers.indexOf(existingReplacer[0]), 1);\n            delete this.revivers[typeId];\n            delete this.types[typeId];\n          }\n\n          if (!spec) {\n            return;\n          }\n\n          if (typeof spec === 'function') {\n            // Support registering just a class without replacer/reviver\n            var Class = spec;\n            spec = {\n              test: function test(x) {\n                return x && x.constructor === Class;\n              },\n              replace: function replace(x) {\n                return Object.assign({}, x);\n              },\n              revive: function revive(x) {\n                return Object.assign(Object.create(Class.prototype), x);\n              }\n            };\n          } else if (isArray(spec)) {\n            var _spec = spec,\n                _spec2 = _slicedToArray(_spec, 3),\n                test = _spec2[0],\n                replace = _spec2[1],\n                revive = _spec2[2];\n\n            spec = {\n              test: test,\n              replace: replace,\n              revive: revive\n            };\n          }\n\n          var replacerObj = {\n            type: typeId,\n            test: spec.test.bind(spec)\n          };\n\n          if (spec.replace) {\n            replacerObj.replace = spec.replace.bind(spec);\n          }\n\n          if (spec.replaceAsync) {\n            replacerObj.replaceAsync = spec.replaceAsync.bind(spec);\n          }\n\n          var start = typeof opts.fallback === 'number' ? opts.fallback : opts.fallback ? 0 : Infinity;\n\n          if (spec.testPlainObjects) {\n            this.plainObjectReplacers.splice(start, 0, replacerObj);\n          } else {\n            this.nonplainObjectReplacers.splice(start, 0, replacerObj);\n          } // Todo: We might consider a testAsync type\n\n\n          if (spec.revive || spec.reviveAsync) {\n            var reviverObj = {};\n\n            if (spec.revive) {\n              reviverObj.revive = spec.revive.bind(spec);\n            }\n\n            if (spec.reviveAsync) {\n              reviverObj.reviveAsync = spec.reviveAsync.bind(spec);\n            }\n\n            this.revivers[typeId] = [reviverObj, {\n              plain: spec.testPlainObjects\n            }];\n          } // Record to be retrieved via public types property.\n\n\n          this.types[typeId] = spec;\n        }, this);\n      }, this);\n      return this;\n    }\n  }]);\n\n  return Typeson;\n}();\n/**\n * We keep this function minimized so if using two instances of this\n * library, where one is minimized and one is not, it will still work\n * with `hasConstructorOf`.\n * @constructor\n */\n\n\nvar Undefined = function Undefined() {\n  _classCallCheck(this, Undefined);\n}; // eslint-disable-line space-before-blocks\n// The following provide classes meant to avoid clashes with other values\n// To insist `undefined` should be added\n\n\nTypeson.Undefined = Undefined; // To support async encapsulation/stringification\n\nTypeson.Promise = TypesonPromise; // Some fundamental type-checking utilities\n\nTypeson.isThenable = isThenable;\nTypeson.toStringTag = toStringTag;\nTypeson.hasConstructorOf = hasConstructorOf;\nTypeson.isObject = isObject;\nTypeson.isPlainObject = isPlainObject;\nTypeson.isUserObject = isUserObject;\nTypeson.escapeKeyPathComponent = escapeKeyPathComponent;\nTypeson.unescapeKeyPathComponent = unescapeKeyPathComponent;\nTypeson.getByKeyPath = getByKeyPath;\nTypeson.getJSONType = getJSONType;\nTypeson.JSON_TYPES = ['null', 'boolean', 'number', 'string', 'array', 'object'];\n\nexport default Typeson;\n","// This does not preserve `undefined` in sparse arrays; see the `undefined`\n//  or `sparse-undefined` preset\nimport Typeson from 'typeson';\n\nconst undef = {\n    undef: {\n        test (x, stateObj) {\n            return typeof x === 'undefined' &&\n                (stateObj.ownKeys || !('ownKeys' in stateObj));\n        },\n        replace (n) { return 0; },\n        revive (s) {\n            // Will add `undefined` (returning `undefined` would instead\n            //   avoid explicitly setting)\n            return new Typeson.Undefined();\n        }\n    }\n};\n\nexport default undef;\n","// This module is for objectified primitives (such as `new Number(3)` or\n//      `new String(\"foo\")`)\n/* eslint-disable no-new-wrappers, unicorn/new-for-builtins */\nimport Typeson from 'typeson';\n\nconst primitiveObjects = {\n    // String Object (not primitive string which need no type spec)\n    StringObject: {\n        test (x) {\n            return Typeson.toStringTag(x) === 'String' && typeof x === 'object';\n        },\n        replace (s) { return String(s); }, // convert to primitive string\n        revive (s) { return new String(s); } // Revive to an objectified string\n    },\n    // Boolean Object (not primitive boolean which need no type spec)\n    BooleanObject: {\n        test (x) {\n            return Typeson.toStringTag(x) === 'Boolean' &&\n                typeof x === 'object';\n        },\n        replace (b) { return Boolean(b); }, // convert to primitive boolean\n        revive (b) {\n            // Revive to an objectified Boolean\n            return new Boolean(b);\n        }\n    },\n    // Number Object (not primitive number which need no type spec)\n    NumberObject: {\n        test (x) {\n            return Typeson.toStringTag(x) === 'Number' && typeof x === 'object';\n        },\n        replace (n) { return Number(n); }, // convert to primitive number\n        revive (n) { return new Number(n); } // Revive to an objectified number\n    }\n};\n/* eslint-enable no-new-wrappers, unicorn/new-for-builtins */\n\nexport default primitiveObjects;\n","import nan from '../types/nan.js';\nimport infinity from '../types/infinity.js';\nimport NegativeInfinity from '../types/negative-infinity.js';\n\nconst specialNumbers = [\n    nan,\n    infinity,\n    NegativeInfinity\n];\n\nexport default specialNumbers;\n","const nan = {\n    nan: {\n        test (x) { return typeof x === 'number' && isNaN(x); },\n        replace (n) { return 'NaN'; },\n        revive (s) { return NaN; }\n    }\n};\n\nexport default nan;\n","const infinity = {\n    infinity: {\n        test (x) { return x === Infinity; },\n        replace (n) { return 'Infinity'; },\n        revive (s) { return Infinity; }\n    }\n};\n\nexport default infinity;\n","const negativeInfinity = {\n    negativeInfinity: {\n        test (x) { return x === -Infinity; },\n        replace (n) { return '-Infinity'; },\n        revive (s) { return -Infinity; }\n    }\n};\n\nexport default negativeInfinity;\n","import Typeson from 'typeson';\n\nconst date = {\n    date: {\n        test (x) { return Typeson.toStringTag(x) === 'Date'; },\n        replace (dt) {\n            const time = dt.getTime();\n            if (isNaN(time)) {\n                return 'NaN';\n            }\n            return time;\n        },\n        revive (time) {\n            if (time === 'NaN') {\n                return new Date(NaN);\n            }\n            return new Date(time);\n        }\n    }\n};\n\nexport default date;\n","import Typeson from 'typeson';\n\nconst error = {\n    error: {\n        test (x) { return Typeson.toStringTag(x) === 'Error'; },\n        replace ({name, message}) {\n            return {name, message};\n        },\n        revive ({name, message}) {\n            const e = new Error(message);\n            e.name = name;\n            return e;\n        }\n    }\n};\n// See also errors.js that may be registered after having registered this type.\n\nexport default error;\n","/* eslint-env browser, node */\nimport Typeson from 'typeson';\n\nconst _global = typeof self === 'undefined' ? global : self;\n\nconst errors = {};\n// Comprises all built-in errors.\n[\n    'TypeError',\n    'RangeError',\n    'SyntaxError',\n    'ReferenceError',\n    'EvalError',\n    'URIError',\n    'InternalError' // non-standard\n].forEach((errName) => {\n    const Cnstrctr = _global[errName];\n    if (Cnstrctr) {\n        errors[errName.toLowerCase()] = {\n            test (x) { return Typeson.hasConstructorOf(x, Cnstrctr); },\n            replace (e) { return e.message; },\n            revive (message) { return new Cnstrctr(message); }\n        };\n    }\n});\n\nexport default errors;\n","/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2017 Brett Zamir, 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; // Use a lookup table to find the index.\n\nvar lookup = new Uint8Array(256);\n\nfor (var i = 0; i < chars.length; i++) {\n  lookup[chars.charCodeAt(i)] = i;\n}\n\nvar encode = function encode(arraybuffer, byteOffset, length) {\n  if (length === null || length === undefined) {\n    length = arraybuffer.byteLength; // Needed for Safari\n  }\n\n  var bytes = new Uint8Array(arraybuffer, byteOffset || 0, // Default needed for Safari\n  length);\n  var len = bytes.length;\n  var base64 = '';\n\n  for (var _i = 0; _i < len; _i += 3) {\n    base64 += chars[bytes[_i] >> 2];\n    base64 += chars[(bytes[_i] & 3) << 4 | bytes[_i + 1] >> 4];\n    base64 += chars[(bytes[_i + 1] & 15) << 2 | bytes[_i + 2] >> 6];\n    base64 += chars[bytes[_i + 2] & 63];\n  }\n\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n\n  return base64;\n};\nvar decode = function decode(base64) {\n  var len = base64.length;\n  var bufferLength = base64.length * 0.75;\n  var p = 0;\n  var encoded1, encoded2, encoded3, encoded4;\n\n  if (base64[base64.length - 1] === '=') {\n    bufferLength--;\n\n    if (base64[base64.length - 2] === '=') {\n      bufferLength--;\n    }\n  }\n\n  var arraybuffer = new ArrayBuffer(bufferLength),\n      bytes = new Uint8Array(arraybuffer);\n\n  for (var _i2 = 0; _i2 < len; _i2 += 4) {\n    encoded1 = lookup[base64.charCodeAt(_i2)];\n    encoded2 = lookup[base64.charCodeAt(_i2 + 1)];\n    encoded3 = lookup[base64.charCodeAt(_i2 + 2)];\n    encoded4 = lookup[base64.charCodeAt(_i2 + 3)];\n    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n\n  return arraybuffer;\n};\n\nexport { decode, encode };\n","import Typeson from 'typeson';\n\nconst regexp = {\n    regexp: {\n        test (x) { return Typeson.toStringTag(x) === 'RegExp'; },\n        replace (rexp) {\n            return {\n                source: rexp.source,\n                flags: (rexp.global ? 'g' : '') +\n                    (rexp.ignoreCase ? 'i' : '') +\n                    (rexp.multiline ? 'm' : '') +\n                    (rexp.sticky ? 'y' : '') +\n                    (rexp.unicode ? 'u' : '')\n            };\n        },\n        revive ({source, flags}) { return new RegExp(source, flags); }\n    }\n};\n\nexport default regexp;\n","import Typeson from 'typeson';\n\nconst map = {\n    map: {\n        test (x) { return Typeson.toStringTag(x) === 'Map'; },\n        replace (mp) { return [...mp.entries()]; },\n        revive (entries) { return new Map(entries); }\n    }\n};\n\nexport default map;\n","import Typeson from 'typeson';\n\nconst set = {\n    set: {\n        test (x) { return Typeson.toStringTag(x) === 'Set'; },\n        replace (st) {\n            return [...st.values()];\n        },\n        revive (values) { return new Set(values); }\n    }\n};\n\nexport default set;\n","import Typeson from 'typeson';\nimport {encode, decode} from 'base64-arraybuffer-es6';\n\nconst arraybuffer = {\n    arraybuffer: {\n        test (x) { return Typeson.toStringTag(x) === 'ArrayBuffer'; },\n        replace (b, stateObj) {\n            if (!stateObj.buffers) {\n                stateObj.buffers = [];\n            }\n            const index = stateObj.buffers.indexOf(b);\n            if (index > -1) {\n                return {index};\n            }\n            stateObj.buffers.push(b);\n            return encode(b);\n        },\n        revive (b64, stateObj) {\n            if (!stateObj.buffers) {\n                stateObj.buffers = [];\n            }\n            if (typeof b64 === 'object') {\n                return stateObj.buffers[b64.index];\n            }\n            const buffer = decode(b64);\n            stateObj.buffers.push(buffer);\n            return buffer;\n        }\n    }\n};\n\nexport default arraybuffer;\n\n// See also typed-arrays!\n","/* eslint-env browser, node */\nimport Typeson from 'typeson';\nimport {encode, decode} from 'base64-arraybuffer-es6';\n\nconst _global = typeof self === 'undefined' ? global : self;\n\nconst typedArrays = {};\n[\n    'Int8Array',\n    'Uint8Array',\n    'Uint8ClampedArray',\n    'Int16Array',\n    'Uint16Array',\n    'Int32Array',\n    'Uint32Array',\n    'Float32Array',\n    'Float64Array'\n].forEach(function (typeName) {\n    const arrType = typeName;\n    const TypedArray = _global[arrType];\n    if (TypedArray) {\n        typedArrays[typeName.toLowerCase()] = {\n            test (x) { return Typeson.toStringTag(x) === arrType; },\n            replace ({buffer, byteOffset, length: l}, stateObj) {\n                if (!stateObj.buffers) {\n                    stateObj.buffers = [];\n                }\n                const index = stateObj.buffers.indexOf(buffer);\n                if (index > -1) {\n                    return {index, byteOffset, length: l};\n                }\n                stateObj.buffers.push(buffer);\n                return {\n                    encoded: encode(buffer),\n                    byteOffset,\n                    length: l\n                };\n            },\n            revive (b64Obj, stateObj) {\n                if (!stateObj.buffers) {\n                    stateObj.buffers = [];\n                }\n                const {byteOffset, length: len, encoded, index} = b64Obj;\n                let buffer;\n                if ('index' in b64Obj) {\n                    buffer = stateObj.buffers[index];\n                } else {\n                    buffer = decode(encoded);\n                    stateObj.buffers.push(buffer);\n                }\n                return new TypedArray(buffer, byteOffset, len);\n            }\n        };\n    }\n});\n\nexport default typedArrays;\n","import Typeson from 'typeson';\nimport {encode, decode} from 'base64-arraybuffer-es6';\n\nconst dataview = {\n    dataview: {\n        test (x) { return Typeson.toStringTag(x) === 'DataView'; },\n        replace ({buffer, byteOffset, byteLength}, stateObj) {\n            if (!stateObj.buffers) {\n                stateObj.buffers = [];\n            }\n            const index = stateObj.buffers.indexOf(buffer);\n            if (index > -1) {\n                return {index, byteOffset, byteLength};\n            }\n            stateObj.buffers.push(buffer);\n            return {\n                encoded: encode(buffer),\n                byteOffset,\n                byteLength\n            };\n        },\n        revive (b64Obj, stateObj) {\n            if (!stateObj.buffers) {\n                stateObj.buffers = [];\n            }\n            const {byteOffset, byteLength, encoded, index} = b64Obj;\n            let buffer;\n            if ('index' in b64Obj) {\n                buffer = stateObj.buffers[index];\n            } else {\n                buffer = decode(encoded);\n                stateObj.buffers.push(buffer);\n            }\n            return new DataView(buffer, byteOffset, byteLength);\n        }\n    }\n};\n\nexport default dataview;\n","import Typeson from 'typeson';\n\nconst IntlCollator = {\n    test (x) { return Typeson.hasConstructorOf(x, Intl.Collator); },\n    replace (c) { return c.resolvedOptions(); },\n    revive (options) { return new Intl.Collator(options.locale, options); }\n};\n\nconst IntlDateTimeFormat = {\n    test (x) { return Typeson.hasConstructorOf(x, Intl.DateTimeFormat); },\n    replace (dtf) { return dtf.resolvedOptions(); },\n    revive (options) {\n        return new Intl.DateTimeFormat(options.locale, options);\n    }\n};\n\nconst IntlNumberFormat = {\n    test (x) { return Typeson.hasConstructorOf(x, Intl.NumberFormat); },\n    replace (nf) { return nf.resolvedOptions(); },\n    revive (options) { return new Intl.NumberFormat(options.locale, options); }\n};\n\nconst intlTypes = {\n    IntlCollator,\n    IntlDateTimeFormat,\n    IntlNumberFormat\n};\n\nexport default intlTypes;\n","/* globals BigInt */\n\nconst bigint = {\n    bigint: {\n        test (x) {\n            // eslint-disable-next-line valid-typeof\n            return typeof x === 'bigint';\n        },\n        replace (n) { return String(n); },\n        revive (s) { return BigInt(s); }\n    }\n};\n\nexport default bigint;\n","/* globals BigInt */\nimport Typeson from 'typeson';\n\nconst bigintObject = {\n    bigintObject: {\n        test (x) {\n            return typeof x === 'object' && Typeson.hasConstructorOf(x, BigInt);\n        },\n        replace (n) { return String(n); },\n        revive (s) {\n            // Filed this to avoid error: https://github.com/eslint/eslint/issues/11810\n            // eslint-disable-next-line no-new-object\n            return new Object(BigInt(s));\n        }\n    }\n};\n\nexport default bigintObject;\n","/* This preset includes types that are built-in into the JavaScript\n    language itself, this should work universally.\n\n  Types that were added in ES6 or beyond will be checked before inclusion\n   so that this module can be consumed by both ES5 and ES6 environments.\n\n  Some types cannot be encapsulated because their inner state is private:\n    `WeakMap`, `WeakSet`.\n\n  The Function type is not included because their closures would not be\n    serialized, so a revived Function that uses closures would not behave\n    as expected.\n\n  Symbols are similarly not included.\n*/\n\nimport arrayNonindexKeys from './array-nonindex-keys.js';\nimport undef from '../types/undef.js';\nimport primitiveObjects from '../types/primitive-objects.js';\nimport specialNumbers from './special-numbers.js';\nimport date from '../types/date.js';\nimport error from '../types/error.js';\nimport errors from '../types/errors.js';\nimport regexp from '../types/regexp.js';\nimport map from '../types/map.js';\nimport set from '../types/set.js';\nimport arraybuffer from '../types/arraybuffer.js';\nimport typedArrays from '../types/typed-arrays.js';\nimport dataview from '../types/dataview.js';\nimport intlTypes from '../types/intl-types.js';\nimport bigint from '../types/bigint.js';\nimport bigintObject from '../types/bigint-object.js';\n\nconst expObj = [\n    undef,\n    // ES5\n    arrayNonindexKeys, primitiveObjects, specialNumbers,\n    date, error, errors, regexp\n].concat(\n    // ES2015 (ES6)\n    typeof Map === 'function' ? map : [],\n    typeof Set === 'function' ? set : [],\n    typeof ArrayBuffer === 'function' ? arraybuffer : [],\n    typeof Uint8Array === 'function' ? typedArrays : [],\n    typeof DataView === 'function' ? dataview : [],\n    typeof Intl !== 'undefined' ? intlTypes : [],\n\n    typeof BigInt !== 'undefined' ? [bigint, bigintObject] : []\n);\nexport default expObj;\n","/* eslint-env browser, node */\nimport Typeson from 'typeson';\n\nconst _global = typeof self === 'undefined' ? global : self;\n\n// Support all kinds of typed arrays (views of ArrayBuffers)\nconst typedArraysSocketIO = {};\n[\n    'Int8Array',\n    'Uint8Array',\n    'Uint8ClampedArray',\n    'Int16Array',\n    'Uint16Array',\n    'Int32Array',\n    'Uint32Array',\n    'Float32Array',\n    'Float64Array'\n].forEach(function (typeName) {\n    const arrType = typeName;\n    const TypedArray = _global[typeName];\n    if (TypedArray) {\n        typedArraysSocketIO[typeName.toLowerCase()] = {\n            test (x) { return Typeson.toStringTag(x) === arrType; },\n            replace (a) {\n                return (a.byteOffset === 0 &&\n                    a.byteLength === a.buffer.byteLength\n                    ? a\n                    // socket.io supports streaming ArrayBuffers.\n                    //   If we have a typed array\n                    // representing a portion of the buffer, we need to clone\n                    //   the buffer before leaving it to socket.io.\n                    : a.slice(0)).buffer;\n            },\n            revive (buf) {\n                // One may configure socket.io to revive binary data as\n                //    Buffer or Blob.\n                // We should therefore not rely on that the instance we\n                //   get here is an ArrayBuffer\n                // If not, let's assume user wants to receive it as\n                //   configured with socket.io.\n                return Typeson.toStringTag(buf) === 'ArrayBuffer'\n                    ? new TypedArray(buf)\n                    : buf;\n            }\n        };\n    }\n});\n\nexport default typedArraysSocketIO;\n","import builtin from './builtin.js';\nimport typedArraysSocketIO from '../types/typed-arrays-socketio.js';\n\nconst socketio = [\n    builtin,\n    // Leave ArrayBuffer as is, and let socket.io stream it instead.\n    {ArrayBuffer: null},\n    // Encapsulate TypedArrays in ArrayBuffers instead of base64 strings.\n    typedArraysSocketIO\n];\n\nexport default socketio;\n"],"names":["arrayNonindexKeys","testPlainObjects","test","x","stateObj","Array","isArray","Object","keys","some","k","String","parseInt","iterateIn","addLength","replace","a","iterateUnsetNumeric","revive","o","arr","forEach","key","val","sparseUndefined","ownKeys","n","s","_typeof","obj","Symbol","_typeof2","iterator","constructor","prototype","asyncGeneratorStep","gen","resolve","reject","_next","_throw","arg","info","value","error","done","Promise","then","_asyncToGenerator","fn","self","this","args","arguments","apply","err","undefined","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","defineProperty","_defineProperty","_objectSpread","source","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_arr","_n","_d","_e","_s","_i","next","push","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","arr2","_iterableToArray","iter","toString","call","from","_nonIterableSpread","TypesonPromise","f","p","toStringTag","onFulfilled","onRejected","_this","typesonResolve","typesonReject","res","r","v","map","meth","promArr","prom","hasOwn","hasOwnProperty","getProto","getPrototypeOf","fnToString","isThenable","catchCheck","isObject","slice","hasConstructorOf","b","proto","Ctor","isPlainObject","escapeKeyPathComponent","keyPathComponent","unescapeKeyPathComponent","getByKeyPath","keyPath","period","indexOf","innerObj","substr","hasOwn$1","internalStateObjPropsToIgnore","nestedPathsFirst","as","keypath","match","bs","Typeson","options","plainObjectReplacers","nonplainObjectReplacers","revivers","types","_createClass","protoProps","staticProps","stringify","replacer","space","opts","stringification","encapsulated","encapsulate","JSON","stringifySync","throwOnBadSyncType","sync","stringifyAsync","parse","text","reviver","parseSync","parseAsync","specialTypeNames","returnTypeNames","rootTypeName","iterateNone","that","refObjs","refKeys","promisesDataRoot","cyclic","encapsulateObserver","ret","_encapsulate","finish","typeNames","values","getJSONType","Set","$types","$","checkPromises","_x","_x2","_checkPromises","regeneratorRuntime","mark","_callee2","promisesData","promResults","wrap","_callee2$","_context2","prev","all","pd","sent","_ref","_callee","promResult","newPromisesData","_promisesData$splice","_promisesData$splice2","prData","_prData","parentObj","detectedType","encaps","isTypesonPromise","encaps2","_callee$","_context","splice","abrupt","stop","_x3","_adaptBuiltinStateObjectProperties","ownKeysObj","cb","assign","vals","prop","tmp","resolvingTypesonPromise","observerData","$typeof","runObserver","type","awaitingTypesonPromise","includes","isNaN","Infinity","replaced","refIndex","cyclicKeypath","clone","isPlainObj","isArr","_loop","kp","endIterateIn","end","endIterateOwn","vl","_loop2","endIterateUnsetNumeric","plainObject","replacers","existing","replaceAsync","replacing","typeDetected","encapsulateSync","encapsulateAsync","keyPathResolutions","ignore$Types","_revive","_clone","Undefined","_keyPathResolutions$","_target","_clone2","_ret","reduce","reducer","Error","reviveAsync","checkUndefined","retrn","possibleTypesonPromise","revivePlainObjects","plainObjectTypes","entries","_ref2","_ref3","plain","sort","_ref4","setAtKeyPath","reviveSync","register","typeSpecSets","R","typeSpec","typeId","JSON_TYPES","spec","existingReplacer","Class","create","_spec2","replacerObj","bind","start","fallback","reviverObj","isUserObject","undef","primitiveObjects","StringObject","BooleanObject","Boolean","NumberObject","Number","specialNumbers","nan","NaN","infinity","negativeInfinity","date","dt","time","getTime","Date","name","message","e","_global","global","errors","errName","Cnstrctr","toLowerCase","regexp","rexp","flags","ignoreCase","multiline","sticky","unicode","RegExp","mp","Map","set","st","chars","lookup","Uint8Array","charCodeAt","encode","arraybuffer","byteOffset","byteLength","bytes","len","base64","substring","decode","encoded1","encoded2","encoded3","encoded4","bufferLength","ArrayBuffer","_i2","buffers","index","b64","buffer","typedArrays","typeName","arrType","TypedArray","l","encoded","b64Obj","dataview","DataView","IntlCollator","Intl","Collator","c","resolvedOptions","locale","IntlDateTimeFormat","DateTimeFormat","dtf","IntlNumberFormat","NumberFormat","nf","bigint","BigInt","bigintObject","expObj","typedArraysSocketIO","buf","builtin"],"mappings":"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"}