{"version":3,"file":"array-nonindex-keys.js","sources":["../../presets/array-nonindex-keys.js"],"sourcesContent":["const arrayNonindexKeys = [\n    {\n        arrayNonindexKeys: {\n            testPlainObjects: true,\n            test (x, stateObj) {\n                if (Array.isArray(x)) {\n                    if (\n                        // By avoiding serializing arrays into objects which\n                        //  have only positive-integer keys, we reduce\n                        //  size and improve revival performance; arrays with\n                        //  non-index keys will be larger however\n                        Object.keys(x).some((k) => {\n                            //  No need to check for `isNaN` or\n                            //   `isNaN(parseInt())` as `NaN` will be treated\n                            //   as a string.\n                            //  No need to do check as `parseInt(Number())`\n                            //   since scientific notation will be\n                            //   pre-resolved if a number was given, and it\n                            //   will otherwise be a string\n                            return String(parseInt(k)) !== k;\n                        })\n                    ) {\n                        stateObj.iterateIn = 'object';\n                        stateObj.addLength = true;\n                    }\n                    return true;\n                }\n                return false;\n            },\n            replace (a, stateObj) {\n                if (Array.isArray(a)) {\n                    // Catch sparse undefined\n                    stateObj.iterateUnsetNumeric = true;\n                }\n                return a;\n            },\n            revive (o) {\n                if (Array.isArray(o)) {\n                    return o;\n                }\n                const arr = [];\n                // No map here as may be a sparse array (including\n                //   with `length` set)\n                // Todo: Reenable when Node `engines` >= 7\n                // Object.entries(o).forEach(([key, val]) => {\n                Object.keys(o).forEach((key) => {\n                    const val = o[key];\n                    arr[key] = val;\n                });\n                return arr;\n            }\n        }\n    },\n    {\n        sparseUndefined: {\n            test (x, stateObj) {\n                return typeof x === 'undefined' && stateObj.ownKeys === false;\n            },\n            replace (n) { return 0; },\n            revive (s) { return undefined; } // Will avoid adding anything\n        }\n    }\n];\n\nexport default arrayNonindexKeys;\n"],"names":["arrayNonindexKeys","testPlainObjects","test","x","stateObj","Array","isArray","Object","keys","some","k","String","parseInt","iterateIn","addLength","replace","a","iterateUnsetNumeric","revive","o","arr","forEach","key","val","sparseUndefined","ownKeys","n","s"],"mappings":"+RAA0B,CACtB,CACIA,kBAAmB,CACfC,kBAAkB,EAClBC,mBAAMC,EAAGC,WACDC,MAAMC,QAAQH,KAMVI,OAAOC,KAAKL,GAAGM,KAAK,SAACC,UAQVC,OAAOC,SAASF,MAAQA,MAGnCN,EAASS,UAAY,SACrBT,EAASU,WAAY,IAElB,IAIfC,yBAASC,EAAGZ,UACJC,MAAMC,QAAQU,KAEdZ,EAASa,qBAAsB,GAE5BD,GAEXE,uBAAQC,MACAd,MAAMC,QAAQa,UACPA,MAELC,EAAM,UAKZb,OAAOC,KAAKW,GAAGE,QAAQ,SAACC,OACdC,EAAMJ,EAAEG,GACdF,EAAIE,GAAOC,IAERH,KAInB,CACII,gBAAiB,CACbtB,mBAAMC,EAAGC,eACe,IAAND,IAA0C,IAArBC,EAASqB,SAEhDV,yBAASW,UAAY,GACrBR,uBAAQS"}